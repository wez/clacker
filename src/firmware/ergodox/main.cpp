#include "src/libs/gpio/AvrGpio.h"
#include "src/libs/lufa/LufaUSB.h"
#include "src/libs/tasks/Tasks.h"

// This file is generated by the KeyMatrix entry in info.py
#include "outputs/src/firmware/ergodox/matrix/matrix-matrix.h"
#include "src/libs/keymatrix/KeyMatrix.h"
#include "src/libs/keyprocessor/KeyProcessor.h"
#include "src/libs/twi/TwoWireMaster.h"

using namespace clacker;
using namespace clacker::gpio;
/* The ergodox is logically rotated by 90 degrees in
 * the matrix wiring; the columns are what we perceive
 * to be the rows of keys going left to right rather
 * than from top to bottom.
 *
 * col:       0   1   2   3   4   5
 * mcu:      F0  F1  F4  F5  F6  F7
 * MCP23018: B5  B4  B3  B2  B1  B0
 *
 * row:       0   1   2   3   4   5   6
 * MCP23018: A0  A1  A2  A3  A4  A5  A6
 *
 * row:       7   8   9   A   B   C   D
 * mcu:      B0  B1  B2  B3  D2  D3  C6
 */
using Col0 = avr::InputPin<avr::PortF, 0, kEnablePullUp>;
using Col1 = avr::InputPin<avr::PortF, 1, kEnablePullUp>;
using Col2 = avr::InputPin<avr::PortF, 4, kEnablePullUp>;
using Col3 = avr::InputPin<avr::PortF, 5, kEnablePullUp>;
using Col4 = avr::InputPin<avr::PortF, 6, kEnablePullUp>;
using Col5 = avr::InputPin<avr::PortF, 7, kEnablePullUp>;

using Row7 = avr::OutputPin<avr::PortB, 0>;
using Row8 = avr::OutputPin<avr::PortB, 1>;
using Row9 = avr::OutputPin<avr::PortB, 2>;
using RowA = avr::OutputPin<avr::PortB, 3>;
using RowB = avr::OutputPin<avr::PortD, 2>;
using RowC = avr::OutputPin<avr::PortD, 3>;
using RowD = avr::OutputPin<avr::PortC, 6>;

using RowPins = avr::OutputPins<Row7, Row8, Row9, RowA, RowB, RowC, RowD>;
using ColPins = avr::InputPins<Col0, Col1, Col2, Col3, Col4, Col5>;

class Scanner {
 public:
  void setup() {
    RowPins::setup();
    ColPins::setup();

    RowPins::write(0);
    memset(matrix_.rows, 0, sizeof(matrix_.rows));
    initMCP23018();
    clearAllRows();
  }

  bool scanMatrix() __attribute__((noinline)) {
    if (!otherHalfOk_ &&
        xTaskGetTickCount() - wentBadTick_ > 500 / portTICK_PERIOD_MS) {
      initMCP23018();
    }

    memcpy(prior_.rows, matrix_.rows, sizeof(prior_.rows));
    memset(matrix_.rows, 0, sizeof(matrix_.rows));
    bool changed = false;

    for (uint8_t row = 0; row < Matrix::RowCount; ++row) {
      selectRow(row);
      _delay_us(30);

      matrix_.rows[row] = row < 7 ? ~readMCP() : ~ColPins::read();
      if (prior_.rows[row] != matrix_.rows[row]) {
        changed = true;
      }
      clearAllRows();
    }

    return changed;
  }

  const Matrix& current() const {
    return matrix_;
  }
  const Matrix& prior() const {
    return prior_;
  }

 private:
  static constexpr uint8_t kAddress = 0b0100000;

  // i/o direction register
  static constexpr uint8_t IODIRA = 0x00;
  static constexpr uint8_t IODIRB = 0x01;

  // GPIO pull-up resistor register
  static constexpr uint8_t GPPUA = 0x0C;
  static constexpr uint8_t GPPUB = 0x0D;

  // general purpose i/o port register
  static constexpr uint8_t GPIOA = 0x12;
  static constexpr uint8_t GPIOB = 0x13;

  void initMCP23018() {
    logln(makeConstString("retry other half"));
    auto twi = TwoWireMaster::get().lock();
    twi->enable(4000000);

    uint8_t data[2] = {
        0b00000000, // for port A
        0b00111111 // for port B
    };
    if (!check(twi->write(kAddress, 100, IODIRA, data))) {
      logln(makeConstString("fail IODIRA"));
      return;
    }
    if (!check(twi->write(kAddress, 100, GPPUA, data))) {
      logln(makeConstString("fail GPPUA"));
      return;
    }

    logln(makeConstString("sync with other half"));
  }

  void clearAllRows() {
    RowPins::write(0);
    if (otherHalfOk_) {
      auto twi = TwoWireMaster::get().lock();
      if (!check(twi->write(kAddress, 100, GPIOA, 0b00111111))) {
        logln(makeConstString("fail set GPIOA"));
      }
    }
  }

  void selectRow(uint8_t row) {
    if (row < 7) {
      if (otherHalfOk_) {
        auto twi = TwoWireMaster::get().lock();
        if (!check(twi->write(kAddress, 100, GPIOA, ~(1 << row)))) {
          logln(makeConstString("fail set GPIOA to rows"));
        }
      }
    } else {
      RowPins::write(~(1 << (row - 7)));
    }
  }

  uint8_t readMCP() {
    if (!otherHalfOk_) {
      logln(makeConstString("known bad, so fail read of GPIOB"));
      return 0;
    }
    auto twi = TwoWireMaster::get().lock();
    uint8_t cols;
    if (!check(twi->read(kAddress, 100, GPIOB, cols))) {
      logln(makeConstString("fail read of GPIOB"));
    }
    return cols;
  }

  bool check(TwiResult&& res) __attribute__((noinline)) {
    if (res.hasValue()) {
      otherHalfOk_ = true;
      return true;
    }
    if (!otherHalfOk_) {
      return false;
    }
    logln(makeConstString("LOST sync with other half"));
    wentBadTick_ = xTaskGetTickCount();
    otherHalfOk_ = false;
    return false;
  }

  Matrix matrix_;
  Matrix prior_;
  bool otherHalfOk_;
  TickType_t wentBadTick_;
};

enum MacroIds {
  MacroCopy,
  MacroPaste,
};
namespace clacker {
ProgMemIter<uint8_t> lookupMacroDefinition(uint16_t macroid) {
  switch (macroid) {
    case MacroCopy:
      static const uint8_t copy[] PROGMEM = {MacroKeyDown,
                                             HID_KEYBOARD_LEFT_GUI,
                                             MacroKeyDown,
                                             HID_KEYBOARD_C_AND_C,
                                             MacroEnd};
      return copy;

    case MacroPaste:
      static const uint8_t paste[] PROGMEM = {MacroKeyDown,
                                              HID_KEYBOARD_LEFT_GUI,
                                              MacroKeyDown,
                                              HID_KEYBOARD_V_AND_V,
                                              MacroEnd};
      return paste;
  }
  return emptyMacroDefinition();
}
}

struct ErgodoxDispatcher {
  void consumerKey(uint16_t code) {
    lufa::LufaUSB::get().consumerKey(code);
  }

  void systemKey(uint16_t code) {
    lufa::LufaUSB::get().systemKey(code);
  }

  void basicReport(const Report& report) {
    lufa::LufaUSB::get().basicReport(report);
  }
};

DispatcherTask<
    ErgodoxDispatcher,
    Matrix,
    Scanner,
    200 // TappingInterval
    >
    scannerTask;

void launchTasks(void) {
  lufa::LufaUSB::get().start().panicIfError();
  scannerTask.start().panicIfError();
}
